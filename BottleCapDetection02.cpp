///////////////////////////////////////////////////////////////////////////////
// File generated by HDevelop for HALCON/C++ Version 25.11.0.0
// Non-ASCII strings in this file are encoded in UTF-8.
// 
// Please note that non-ASCII characters in string constants are exported
// as octal codes in order to guarantee that the strings are correctly
// created on all systems, independent on any compiler settings.
// 
// Source files with different encoding should not be mixed in one project.
///////////////////////////////////////////////////////////////////////////////
#include "HalconCpp.h"
#include "HDevThread.h"



using namespace HalconCpp;

namespace MyVision
{

//Note global variables cannot be shared across exports with different namespace

#ifndef NO_EXPORT_MAIN
// Main procedure 
void action()
{

  // Local iconic variables
  HObject  ho_Images, ho_ImageRed, ho_ImageGreen;
  HObject  ho_ImageBlue, ho_ImageH, ho_ImageS, ho_ImageV, ho_RegionH;
  HObject  ho_RegionS, ho_BlueCandidates, ho_ConnectedRegions;
  HObject  ho_RegionFillUp, ho_RegionOpening, ho_SelectedRegions;
  HObject  ho_RegionUnion, ho_DistanceImage, ho_DistanceImageUint2;
  HObject  ho_DistanceImageInvert, ho_Watersheds, ho_FinalCaps;
  HObject  ho_RealCaps;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_WindowHandle;
  HTuple  hv_Number;

  //==========================================
  //1. 图像采集
  //==========================================
  ReadImage(&ho_Images, "E:/halcon/LX/Gemini_Generated_Image_csuu7acsuu7acsuu.png");
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  GetImageSize(ho_Images, &hv_Width, &hv_Height);
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,hv_Width/4,hv_Height/4,0,"visible","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  if (HDevWindowStack::IsOpen())
    SetPart(HDevWindowStack::GetActive(),0, 0, hv_Height-1, hv_Width-1);

  //==========================================
  //2. HSV 转换
  //==========================================
  Decompose3(ho_Images, &ho_ImageRed, &ho_ImageGreen, &ho_ImageBlue);
  TransFromRgb(ho_ImageRed, ho_ImageGreen, ho_ImageBlue, &ho_ImageH, &ho_ImageS, 
      &ho_ImageV, "hsv");

  //==========================================
  //==========================================
  //3. 特征提取 (锁定蓝色)
  //==========================================
  Threshold(ho_ImageH, &ho_RegionH, 130, 180);
  Threshold(ho_ImageS, &ho_RegionS, 80, 255);
  Intersection(ho_RegionH, ho_RegionS, &ho_BlueCandidates);

  //==========================================
  //4. 核心修正：形态学调优（平衡点）
  //==========================================
  Connection(ho_BlueCandidates, &ho_ConnectedRegions);

  //[保留]：填补反光空洞是必须的，这个不能动
  FillUp(ho_ConnectedRegions, &ho_RegionFillUp);

  //[关键回调 A]：把磨皮力度减小。从 5.5 降回 3.5
  //既能磨平毛刺，又不至于把缝隙给磨没了
  OpeningCircle(ho_RegionFillUp, &ho_RegionOpening, 3.5);

  //面积筛选保持不变
  SelectShape(ho_RegionOpening, &ho_SelectedRegions, "area", "and", 2000, 99999999);

  //==========================================
  //5. 稳健拓扑切割（平衡点）
  //==========================================
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  DistanceTransform(ho_RegionUnion, &ho_DistanceImage, "euclidean", "true", hv_Width, 
      hv_Height);
  ConvertImageType(ho_DistanceImage, &ho_DistanceImageUint2, "uint2");
  InvertImage(ho_DistanceImageUint2, &ho_DistanceImageInvert);

  //[关键回调 B]：把手术刀磨快一点。从 80 降回 40
  //这个值是分割粘连的核心。数值越小，切得越细。40 是一个经验上的中庸值。
  WatershedsThreshold(ho_DistanceImageInvert, &ho_Watersheds, 40);
  Intersection(ho_Watersheds, ho_RegionUnion, &ho_FinalCaps);

  //[关键新增]：增加圆度筛选
  //切割后可能会产生一些奇形怪状的碎片，用圆度把它们过滤掉
  SelectShape(ho_FinalCaps, &ho_RealCaps, (HTuple("area").Append("circularity")), 
      "and", (HTuple(800).Append(0.2)), (HTuple(99999999).Append(1.0)));
  //==========================================
  //6. 结果显示
  //==========================================
  if (HDevWindowStack::IsOpen())
    DispObj(ho_Images, HDevWindowStack::GetActive());
  if (HDevWindowStack::IsOpen())
    SetColored(HDevWindowStack::GetActive(),12);
  if (HDevWindowStack::IsOpen())
    DispObj(ho_RealCaps, HDevWindowStack::GetActive());

  CountObj(ho_RealCaps, &hv_Number);
  if (HDevWindowStack::IsOpen())
    DispText(HDevWindowStack::GetActive(),//'修正反光后，检测到蓝色瓶盖数量: '
      "\344\277\256\346\255\243\345\217\215\345\205\211\345\220\216\357\274\214\346\243\200\346\265\213\345\210\260\350\223\235\350\211\262\347\223\266\347\233\226\346\225\260\351\207\217: "+hv_Number, 
        "window", 12, 12, "black", HTuple(), HTuple());
}


#ifndef NO_EXPORT_APP_MAIN


} // end namespace

int main(int argc, char *argv[])
{
  int ret = 0;

  try
  {
#if defined(_WIN32)
    SetSystem("use_window_thread", "true");
#endif

    // Default settings used in HDevelop (can be omitted)
    SetSystem("width", 512);
    SetSystem("height", 512);

    MyVision::action();
  }
  catch (HException &exception)
  {
    fprintf(stderr,"  Error #%u in %s: %s\n", exception.ErrorCode(),
            exception.ProcName().TextA(),
            exception.ErrorMessage().TextA());
    ret = 1;
  }

#if defined(_WIN32)
  // On Windows socket communication is no longer possible after returning
  // from main, so HALCON cannot return floating licenses automatically.
  try
  {
    SetSystem("return_license", "true");
  }
  catch (...)
  {
    // Ignore any errors that might occur when returning the license.
  }
#endif

  return ret;
}
namespace MyVision
{


#endif


#endif


} // end namespace

